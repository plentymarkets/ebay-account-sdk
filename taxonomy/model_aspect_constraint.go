/*
Taxonomy API

Use the Taxonomy API to discover the most appropriate eBay categories under which sellers can offer inventory items for sale, and the most likely categories under which buyers can browse or search for items to purchase. In addition, the Taxonomy API provides metadata about the required and recommended category aspects to include in listings, and also has two operations to retrieve parts compatibility information.

API version: v1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package taxonomy

import (
	"encoding/json"
)

// AspectConstraint This type contains information about the formatting, occurrence, and support of an aspect.
type AspectConstraint struct {
	// This value indicate if the aspect identified by the aspects.localizedAspectName field is a product aspect (relevant to catalog products in the category) or an item/instance aspect, which is an aspect whose value will vary based on a particular instance of the product.
	AspectApplicableTo *[]string `json:"aspectApplicableTo,omitempty"`
	// The data type of this aspect. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:AspectDataTypeEnum'>eBay API documentation</a>
	AspectDataType *string `json:"aspectDataType,omitempty"`
	// A value of true indicates that this aspect can be used to help identify item variations.
	AspectEnabledForVariations *bool `json:"aspectEnabledForVariations,omitempty"`
	// Returned only if the value of aspectDataType identifies a data type that requires specific formatting. Currently, this field provides formatting hints as follows: DATE: YYYY, YYYYMM, YYYYMMDD NUMBER: int32, double
	AspectFormat *string `json:"aspectFormat,omitempty"`
	// The maximum length of the item/instance aspect's value. The seller must make sure not to exceed this length when specifying the instance aspect's value for a product. This field is only returned for instance aspects.
	AspectMaxLength *int32 `json:"aspectMaxLength,omitempty"`
	// The manner in which values of this aspect must be specified by the seller (as free text or by selecting from available options). For implementation help, refer to <a href='https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:AspectModeEnum'>eBay API documentation</a>
	AspectMode *string `json:"aspectMode,omitempty"`
	// A value of true indicates that this aspect is required when offering items in the specified category.
	AspectRequired *bool `json:"aspectRequired,omitempty"`
	// The enumeration value returned in this field will indicate if the corresponding aspect is recommended or optional. Note: This field is always returned, even for hard-mandated/required aspects (where aspectRequired: true). The value returned for required aspects will be RECOMMENDED, but they are actually required and a seller will be blocked from listing or revising an item without these aspects. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:AspectUsageEnum'>eBay API documentation</a>
	AspectUsage *string `json:"aspectUsage,omitempty"`
	// The expected date after which the aspect will be required. Note: The value returned in this field specifies only an approximate date, which may not reflect the actual date after which the aspect is required.
	ExpectedRequiredByDate *string `json:"expectedRequiredByDate,omitempty"`
	// Indicates whether this aspect can accept single or multiple values for items in the specified category. For implementation help, refer to <a href='https://developer.ebay.com/api-docs/commerce/taxonomy/types/txn:ItemToAspectCardinalityEnum'>eBay API documentation</a>
	ItemToAspectCardinality *string `json:"itemToAspectCardinality,omitempty"`
}

// NewAspectConstraint instantiates a new AspectConstraint object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewAspectConstraint() *AspectConstraint {
	this := AspectConstraint{}
	return &this
}

// NewAspectConstraintWithDefaults instantiates a new AspectConstraint object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewAspectConstraintWithDefaults() *AspectConstraint {
	this := AspectConstraint{}
	return &this
}

// GetAspectApplicableTo returns the AspectApplicableTo field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectApplicableTo() []string {
	if o == nil || o.AspectApplicableTo == nil {
		var ret []string
		return ret
	}
	return *o.AspectApplicableTo
}

// GetAspectApplicableToOk returns a tuple with the AspectApplicableTo field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectApplicableToOk() (*[]string, bool) {
	if o == nil || o.AspectApplicableTo == nil {
		return nil, false
	}
	return o.AspectApplicableTo, true
}

// HasAspectApplicableTo returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectApplicableTo() bool {
	if o != nil && o.AspectApplicableTo != nil {
		return true
	}

	return false
}

// SetAspectApplicableTo gets a reference to the given []string and assigns it to the AspectApplicableTo field.
func (o *AspectConstraint) SetAspectApplicableTo(v []string) {
	o.AspectApplicableTo = &v
}

// GetAspectDataType returns the AspectDataType field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectDataType() string {
	if o == nil || o.AspectDataType == nil {
		var ret string
		return ret
	}
	return *o.AspectDataType
}

// GetAspectDataTypeOk returns a tuple with the AspectDataType field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectDataTypeOk() (*string, bool) {
	if o == nil || o.AspectDataType == nil {
		return nil, false
	}
	return o.AspectDataType, true
}

// HasAspectDataType returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectDataType() bool {
	if o != nil && o.AspectDataType != nil {
		return true
	}

	return false
}

// SetAspectDataType gets a reference to the given string and assigns it to the AspectDataType field.
func (o *AspectConstraint) SetAspectDataType(v string) {
	o.AspectDataType = &v
}

// GetAspectEnabledForVariations returns the AspectEnabledForVariations field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectEnabledForVariations() bool {
	if o == nil || o.AspectEnabledForVariations == nil {
		var ret bool
		return ret
	}
	return *o.AspectEnabledForVariations
}

// GetAspectEnabledForVariationsOk returns a tuple with the AspectEnabledForVariations field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectEnabledForVariationsOk() (*bool, bool) {
	if o == nil || o.AspectEnabledForVariations == nil {
		return nil, false
	}
	return o.AspectEnabledForVariations, true
}

// HasAspectEnabledForVariations returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectEnabledForVariations() bool {
	if o != nil && o.AspectEnabledForVariations != nil {
		return true
	}

	return false
}

// SetAspectEnabledForVariations gets a reference to the given bool and assigns it to the AspectEnabledForVariations field.
func (o *AspectConstraint) SetAspectEnabledForVariations(v bool) {
	o.AspectEnabledForVariations = &v
}

// GetAspectFormat returns the AspectFormat field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectFormat() string {
	if o == nil || o.AspectFormat == nil {
		var ret string
		return ret
	}
	return *o.AspectFormat
}

// GetAspectFormatOk returns a tuple with the AspectFormat field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectFormatOk() (*string, bool) {
	if o == nil || o.AspectFormat == nil {
		return nil, false
	}
	return o.AspectFormat, true
}

// HasAspectFormat returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectFormat() bool {
	if o != nil && o.AspectFormat != nil {
		return true
	}

	return false
}

// SetAspectFormat gets a reference to the given string and assigns it to the AspectFormat field.
func (o *AspectConstraint) SetAspectFormat(v string) {
	o.AspectFormat = &v
}

// GetAspectMaxLength returns the AspectMaxLength field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectMaxLength() int32 {
	if o == nil || o.AspectMaxLength == nil {
		var ret int32
		return ret
	}
	return *o.AspectMaxLength
}

// GetAspectMaxLengthOk returns a tuple with the AspectMaxLength field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectMaxLengthOk() (*int32, bool) {
	if o == nil || o.AspectMaxLength == nil {
		return nil, false
	}
	return o.AspectMaxLength, true
}

// HasAspectMaxLength returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectMaxLength() bool {
	if o != nil && o.AspectMaxLength != nil {
		return true
	}

	return false
}

// SetAspectMaxLength gets a reference to the given int32 and assigns it to the AspectMaxLength field.
func (o *AspectConstraint) SetAspectMaxLength(v int32) {
	o.AspectMaxLength = &v
}

// GetAspectMode returns the AspectMode field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectMode() string {
	if o == nil || o.AspectMode == nil {
		var ret string
		return ret
	}
	return *o.AspectMode
}

// GetAspectModeOk returns a tuple with the AspectMode field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectModeOk() (*string, bool) {
	if o == nil || o.AspectMode == nil {
		return nil, false
	}
	return o.AspectMode, true
}

// HasAspectMode returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectMode() bool {
	if o != nil && o.AspectMode != nil {
		return true
	}

	return false
}

// SetAspectMode gets a reference to the given string and assigns it to the AspectMode field.
func (o *AspectConstraint) SetAspectMode(v string) {
	o.AspectMode = &v
}

// GetAspectRequired returns the AspectRequired field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectRequired() bool {
	if o == nil || o.AspectRequired == nil {
		var ret bool
		return ret
	}
	return *o.AspectRequired
}

// GetAspectRequiredOk returns a tuple with the AspectRequired field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectRequiredOk() (*bool, bool) {
	if o == nil || o.AspectRequired == nil {
		return nil, false
	}
	return o.AspectRequired, true
}

// HasAspectRequired returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectRequired() bool {
	if o != nil && o.AspectRequired != nil {
		return true
	}

	return false
}

// SetAspectRequired gets a reference to the given bool and assigns it to the AspectRequired field.
func (o *AspectConstraint) SetAspectRequired(v bool) {
	o.AspectRequired = &v
}

// GetAspectUsage returns the AspectUsage field value if set, zero value otherwise.
func (o *AspectConstraint) GetAspectUsage() string {
	if o == nil || o.AspectUsage == nil {
		var ret string
		return ret
	}
	return *o.AspectUsage
}

// GetAspectUsageOk returns a tuple with the AspectUsage field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetAspectUsageOk() (*string, bool) {
	if o == nil || o.AspectUsage == nil {
		return nil, false
	}
	return o.AspectUsage, true
}

// HasAspectUsage returns a boolean if a field has been set.
func (o *AspectConstraint) HasAspectUsage() bool {
	if o != nil && o.AspectUsage != nil {
		return true
	}

	return false
}

// SetAspectUsage gets a reference to the given string and assigns it to the AspectUsage field.
func (o *AspectConstraint) SetAspectUsage(v string) {
	o.AspectUsage = &v
}

// GetExpectedRequiredByDate returns the ExpectedRequiredByDate field value if set, zero value otherwise.
func (o *AspectConstraint) GetExpectedRequiredByDate() string {
	if o == nil || o.ExpectedRequiredByDate == nil {
		var ret string
		return ret
	}
	return *o.ExpectedRequiredByDate
}

// GetExpectedRequiredByDateOk returns a tuple with the ExpectedRequiredByDate field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetExpectedRequiredByDateOk() (*string, bool) {
	if o == nil || o.ExpectedRequiredByDate == nil {
		return nil, false
	}
	return o.ExpectedRequiredByDate, true
}

// HasExpectedRequiredByDate returns a boolean if a field has been set.
func (o *AspectConstraint) HasExpectedRequiredByDate() bool {
	if o != nil && o.ExpectedRequiredByDate != nil {
		return true
	}

	return false
}

// SetExpectedRequiredByDate gets a reference to the given string and assigns it to the ExpectedRequiredByDate field.
func (o *AspectConstraint) SetExpectedRequiredByDate(v string) {
	o.ExpectedRequiredByDate = &v
}

// GetItemToAspectCardinality returns the ItemToAspectCardinality field value if set, zero value otherwise.
func (o *AspectConstraint) GetItemToAspectCardinality() string {
	if o == nil || o.ItemToAspectCardinality == nil {
		var ret string
		return ret
	}
	return *o.ItemToAspectCardinality
}

// GetItemToAspectCardinalityOk returns a tuple with the ItemToAspectCardinality field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *AspectConstraint) GetItemToAspectCardinalityOk() (*string, bool) {
	if o == nil || o.ItemToAspectCardinality == nil {
		return nil, false
	}
	return o.ItemToAspectCardinality, true
}

// HasItemToAspectCardinality returns a boolean if a field has been set.
func (o *AspectConstraint) HasItemToAspectCardinality() bool {
	if o != nil && o.ItemToAspectCardinality != nil {
		return true
	}

	return false
}

// SetItemToAspectCardinality gets a reference to the given string and assigns it to the ItemToAspectCardinality field.
func (o *AspectConstraint) SetItemToAspectCardinality(v string) {
	o.ItemToAspectCardinality = &v
}

func (o AspectConstraint) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.AspectApplicableTo != nil {
		toSerialize["aspectApplicableTo"] = o.AspectApplicableTo
	}
	if o.AspectDataType != nil {
		toSerialize["aspectDataType"] = o.AspectDataType
	}
	if o.AspectEnabledForVariations != nil {
		toSerialize["aspectEnabledForVariations"] = o.AspectEnabledForVariations
	}
	if o.AspectFormat != nil {
		toSerialize["aspectFormat"] = o.AspectFormat
	}
	if o.AspectMaxLength != nil {
		toSerialize["aspectMaxLength"] = o.AspectMaxLength
	}
	if o.AspectMode != nil {
		toSerialize["aspectMode"] = o.AspectMode
	}
	if o.AspectRequired != nil {
		toSerialize["aspectRequired"] = o.AspectRequired
	}
	if o.AspectUsage != nil {
		toSerialize["aspectUsage"] = o.AspectUsage
	}
	if o.ExpectedRequiredByDate != nil {
		toSerialize["expectedRequiredByDate"] = o.ExpectedRequiredByDate
	}
	if o.ItemToAspectCardinality != nil {
		toSerialize["itemToAspectCardinality"] = o.ItemToAspectCardinality
	}
	return json.Marshal(toSerialize)
}

type NullableAspectConstraint struct {
	value *AspectConstraint
	isSet bool
}

func (v NullableAspectConstraint) Get() *AspectConstraint {
	return v.value
}

func (v *NullableAspectConstraint) Set(val *AspectConstraint) {
	v.value = val
	v.isSet = true
}

func (v NullableAspectConstraint) IsSet() bool {
	return v.isSet
}

func (v *NullableAspectConstraint) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAspectConstraint(val *AspectConstraint) *NullableAspectConstraint {
	return &NullableAspectConstraint{value: val, isSet: true}
}

func (v NullableAspectConstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAspectConstraint) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


