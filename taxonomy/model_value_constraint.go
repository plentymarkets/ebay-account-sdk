/*
Taxonomy API

Use the Taxonomy API to discover the most appropriate eBay categories under which sellers can offer inventory items for sale, and the most likely categories under which buyers can browse or search for items to purchase. In addition, the Taxonomy API provides metadata about the required and recommended category aspects to include in listings, and also has two operations to retrieve parts compatibility information.

API version: v1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package taxonomy

import (
	"encoding/json"
)

// ValueConstraint This type contains a list of the dependencies that identify when a particular value is available for a given aspect of a given category. Each dependency specifies the values of another aspect of the same category (the control aspect), for which the given value of the given aspect can also be selected by the seller. This container consists of constraint information for the corresponding product aspect value.
type ValueConstraint struct {
	// The name of the control aspect on which the current aspect value depends.
	ApplicableForLocalizedAspectName *string `json:"applicableForLocalizedAspectName,omitempty"`
	// Contains a list of the values of the control aspect on which this aspect's value depends. When the control aspect has any of the specified values, the current value of the current aspect will also be available.
	ApplicableForLocalizedAspectValues *[]string `json:"applicableForLocalizedAspectValues,omitempty"`
}

// NewValueConstraint instantiates a new ValueConstraint object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewValueConstraint() *ValueConstraint {
	this := ValueConstraint{}
	return &this
}

// NewValueConstraintWithDefaults instantiates a new ValueConstraint object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewValueConstraintWithDefaults() *ValueConstraint {
	this := ValueConstraint{}
	return &this
}

// GetApplicableForLocalizedAspectName returns the ApplicableForLocalizedAspectName field value if set, zero value otherwise.
func (o *ValueConstraint) GetApplicableForLocalizedAspectName() string {
	if o == nil || o.ApplicableForLocalizedAspectName == nil {
		var ret string
		return ret
	}
	return *o.ApplicableForLocalizedAspectName
}

// GetApplicableForLocalizedAspectNameOk returns a tuple with the ApplicableForLocalizedAspectName field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ValueConstraint) GetApplicableForLocalizedAspectNameOk() (*string, bool) {
	if o == nil || o.ApplicableForLocalizedAspectName == nil {
		return nil, false
	}
	return o.ApplicableForLocalizedAspectName, true
}

// HasApplicableForLocalizedAspectName returns a boolean if a field has been set.
func (o *ValueConstraint) HasApplicableForLocalizedAspectName() bool {
	if o != nil && o.ApplicableForLocalizedAspectName != nil {
		return true
	}

	return false
}

// SetApplicableForLocalizedAspectName gets a reference to the given string and assigns it to the ApplicableForLocalizedAspectName field.
func (o *ValueConstraint) SetApplicableForLocalizedAspectName(v string) {
	o.ApplicableForLocalizedAspectName = &v
}

// GetApplicableForLocalizedAspectValues returns the ApplicableForLocalizedAspectValues field value if set, zero value otherwise.
func (o *ValueConstraint) GetApplicableForLocalizedAspectValues() []string {
	if o == nil || o.ApplicableForLocalizedAspectValues == nil {
		var ret []string
		return ret
	}
	return *o.ApplicableForLocalizedAspectValues
}

// GetApplicableForLocalizedAspectValuesOk returns a tuple with the ApplicableForLocalizedAspectValues field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *ValueConstraint) GetApplicableForLocalizedAspectValuesOk() (*[]string, bool) {
	if o == nil || o.ApplicableForLocalizedAspectValues == nil {
		return nil, false
	}
	return o.ApplicableForLocalizedAspectValues, true
}

// HasApplicableForLocalizedAspectValues returns a boolean if a field has been set.
func (o *ValueConstraint) HasApplicableForLocalizedAspectValues() bool {
	if o != nil && o.ApplicableForLocalizedAspectValues != nil {
		return true
	}

	return false
}

// SetApplicableForLocalizedAspectValues gets a reference to the given []string and assigns it to the ApplicableForLocalizedAspectValues field.
func (o *ValueConstraint) SetApplicableForLocalizedAspectValues(v []string) {
	o.ApplicableForLocalizedAspectValues = &v
}

func (o ValueConstraint) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.ApplicableForLocalizedAspectName != nil {
		toSerialize["applicableForLocalizedAspectName"] = o.ApplicableForLocalizedAspectName
	}
	if o.ApplicableForLocalizedAspectValues != nil {
		toSerialize["applicableForLocalizedAspectValues"] = o.ApplicableForLocalizedAspectValues
	}
	return json.Marshal(toSerialize)
}

type NullableValueConstraint struct {
	value *ValueConstraint
	isSet bool
}

func (v NullableValueConstraint) Get() *ValueConstraint {
	return v.value
}

func (v *NullableValueConstraint) Set(val *ValueConstraint) {
	v.value = val
	v.isSet = true
}

func (v NullableValueConstraint) IsSet() bool {
	return v.isSet
}

func (v *NullableValueConstraint) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableValueConstraint(val *ValueConstraint) *NullableValueConstraint {
	return &NullableValueConstraint{value: val, isSet: true}
}

func (v NullableValueConstraint) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableValueConstraint) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


