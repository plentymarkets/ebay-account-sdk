/*
Account API

The <b>Account API</b> gives sellers the ability to configure their eBay seller accounts, including the seller's policies (the Fulfillment Policy, Payment Policy, and Return Policy), opt in and out of eBay seller programs, configure sales tax tables, and get account information.  <br><br>For details on the availability of the methods in this API, see <a href=\"/api-docs/sell/account/overview.html#requirements\">Account API requirements and restrictions</a>.

API version: v1.6.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package account

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// FulfillmentPolicyApiService FulfillmentPolicyApi service
type FulfillmentPolicyApiService service

type ApiCreateFulfillmentPolicyRequest struct {
	ctx _context.Context
	ApiService *FulfillmentPolicyApiService
	fulfillmentPolicyRequest *FulfillmentPolicyRequest
}

// Request to create a seller account fulfillment policy.
func (r ApiCreateFulfillmentPolicyRequest) FulfillmentPolicyRequest(fulfillmentPolicyRequest FulfillmentPolicyRequest) ApiCreateFulfillmentPolicyRequest {
	r.fulfillmentPolicyRequest = &fulfillmentPolicyRequest
	return r
}

func (r ApiCreateFulfillmentPolicyRequest) Execute() (SetFulfillmentPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateFulfillmentPolicyExecute(r)
}

/*
CreateFulfillmentPolicy Method for CreateFulfillmentPolicy

This method creates a new fulfillment policy where the policy encapsulates seller's terms for fulfilling item purchases. Fulfillment policies include the shipment options that the seller offers to buyers.  <br><br>Each policy targets a <b>marketplaceId</b> and <code>categoryTypes.</code><b>name</b> combination and you can create multiple policies for each combination. Be aware that some marketplaces require a specific fulfillment policy for vehicle listings.  <br><br>A successful request returns the URI to the new policy in the <b>Location</b> response header and the ID for the new policy is returned in the response payload.  <p class="tablenote"><b>Tip:</b> For details on creating and using the business policies supported by the Account API, see <a href="/api-docs/sell/static/seller-accounts/business-policies.html">eBay business policies</a>.</p>  <p><b>Marketplaces and locales</b></p>  <p>Policy instructions can be localized by providing a locale in the <code>Accept-Language</code> HTTP request header. For example, the following setting displays field values from the request body in German: <code>Accept-Language: de-DE</code>.</p>  <p>Target the specific locale of a marketplace that supports multiple locales using the <code>Content-Language</code> request header. For example, target the French locale of the Canadian marketplace by specifying the <code>fr-CA</code> locale for <code>Content-Language</code>. Likewise, target the Dutch locale of the Belgium marketplace by setting <code>Content-Language: nl-BE</code>.</p> <p class="tablenote"><b>Tip:</b> For details on headers, see <a href="/api-docs/static/rest-request-components.html#HTTP">HTTP request headers</a>.</p>

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFulfillmentPolicyRequest
*/
func (a *FulfillmentPolicyApiService) CreateFulfillmentPolicy(ctx _context.Context) ApiCreateFulfillmentPolicyRequest {
	return ApiCreateFulfillmentPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SetFulfillmentPolicyResponse
func (a *FulfillmentPolicyApiService) CreateFulfillmentPolicyExecute(r ApiCreateFulfillmentPolicyRequest) (SetFulfillmentPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SetFulfillmentPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentPolicyApiService.CreateFulfillmentPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fulfillment_policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fulfillmentPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("fulfillmentPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fulfillmentPolicyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFulfillmentPolicyRequest struct {
	ctx _context.Context
	ApiService *FulfillmentPolicyApiService
	fulfillmentPolicyId string
}


func (r ApiDeleteFulfillmentPolicyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteFulfillmentPolicyExecute(r)
}

/*
DeleteFulfillmentPolicy Method for DeleteFulfillmentPolicy

This method deletes a fulfillment policy. Supply the ID of the policy you want to delete in the <b>fulfillmentPolicyId</b> path parameter. Note that you cannot delete the default fulfillment policy.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fulfillmentPolicyId This path parameter specifies the ID of the fulfillment policy to delete.
 @return ApiDeleteFulfillmentPolicyRequest
*/
func (a *FulfillmentPolicyApiService) DeleteFulfillmentPolicy(ctx _context.Context, fulfillmentPolicyId string) ApiDeleteFulfillmentPolicyRequest {
	return ApiDeleteFulfillmentPolicyRequest{
		ApiService: a,
		ctx: ctx,
		fulfillmentPolicyId: fulfillmentPolicyId,
	}
}

// Execute executes the request
func (a *FulfillmentPolicyApiService) DeleteFulfillmentPolicyExecute(r ApiDeleteFulfillmentPolicyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentPolicyApiService.DeleteFulfillmentPolicy")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fulfillment_policy/{fulfillmentPolicyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fulfillmentPolicyId"+"}", _neturl.PathEscape(parameterToString(r.fulfillmentPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFulfillmentPoliciesRequest struct {
	ctx _context.Context
	ApiService *FulfillmentPolicyApiService
	marketplaceId *string
}

// This query parameter specifies the eBay marketplace of the policies you want to retrieve. For implementation help, refer to eBay API documentation at https://developer.ebay.com/api-docs/sell/account/types/ba:MarketplaceIdEnum
func (r ApiGetFulfillmentPoliciesRequest) MarketplaceId(marketplaceId string) ApiGetFulfillmentPoliciesRequest {
	r.marketplaceId = &marketplaceId
	return r
}

func (r ApiGetFulfillmentPoliciesRequest) Execute() (FulfillmentPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.GetFulfillmentPoliciesExecute(r)
}

/*
GetFulfillmentPolicies Method for GetFulfillmentPolicies

This method retrieves all the fulfillment policies configured for the marketplace you specify using the <code>marketplace_id</code> query parameter.  <br><br><b>Marketplaces and locales</b>  <br><br>Get the correct policies for a marketplace that supports multiple locales using the <code>Content-Language</code> request header. For example, get the policies for the French locale of the Canadian marketplace by specifying <code>fr-CA</code> for the <code>Content-Language</code> header. Likewise, target the Dutch locale of the Belgium marketplace by setting <code>Content-Language: nl-BE</code>. For details on header values, see <a href="/api-docs/static/rest-request-components.html#HTTP" target="_blank">HTTP request headers</a>.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFulfillmentPoliciesRequest
*/
func (a *FulfillmentPolicyApiService) GetFulfillmentPolicies(ctx _context.Context) ApiGetFulfillmentPoliciesRequest {
	return ApiGetFulfillmentPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FulfillmentPolicyResponse
func (a *FulfillmentPolicyApiService) GetFulfillmentPoliciesExecute(r ApiGetFulfillmentPoliciesRequest) (FulfillmentPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FulfillmentPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentPolicyApiService.GetFulfillmentPolicies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fulfillment_policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.marketplaceId == nil {
		return localVarReturnValue, nil, reportError("marketplaceId is required and must be specified")
	}

	localVarQueryParams.Add("marketplace_id", parameterToString(*r.marketplaceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFulfillmentPolicyRequest struct {
	ctx _context.Context
	ApiService *FulfillmentPolicyApiService
	fulfillmentPolicyId string
}


func (r ApiGetFulfillmentPolicyRequest) Execute() (FulfillmentPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetFulfillmentPolicyExecute(r)
}

/*
GetFulfillmentPolicy Method for GetFulfillmentPolicy

This method retrieves the complete details of a fulfillment policy. Supply the ID of the policy you want to retrieve using the <b>fulfillmentPolicyId</b> path parameter.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fulfillmentPolicyId This path parameter specifies the ID of the fulfillment policy you want to retrieve.
 @return ApiGetFulfillmentPolicyRequest
*/
func (a *FulfillmentPolicyApiService) GetFulfillmentPolicy(ctx _context.Context, fulfillmentPolicyId string) ApiGetFulfillmentPolicyRequest {
	return ApiGetFulfillmentPolicyRequest{
		ApiService: a,
		ctx: ctx,
		fulfillmentPolicyId: fulfillmentPolicyId,
	}
}

// Execute executes the request
//  @return FulfillmentPolicy
func (a *FulfillmentPolicyApiService) GetFulfillmentPolicyExecute(r ApiGetFulfillmentPolicyRequest) (FulfillmentPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FulfillmentPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentPolicyApiService.GetFulfillmentPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fulfillment_policy/{fulfillmentPolicyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fulfillmentPolicyId"+"}", _neturl.PathEscape(parameterToString(r.fulfillmentPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFulfillmentPolicyByNameRequest struct {
	ctx _context.Context
	ApiService *FulfillmentPolicyApiService
	marketplaceId *string
	name *string
}

// This query parameter specifies the eBay marketplace of the policy you want to retrieve. For implementation help, refer to eBay API documentation at https://developer.ebay.com/api-docs/sell/account/types/ba:MarketplaceIdEnum
func (r ApiGetFulfillmentPolicyByNameRequest) MarketplaceId(marketplaceId string) ApiGetFulfillmentPolicyByNameRequest {
	r.marketplaceId = &marketplaceId
	return r
}
// This query parameter specifies the user-defined name of the fulfillment policy you want to retrieve.
func (r ApiGetFulfillmentPolicyByNameRequest) Name(name string) ApiGetFulfillmentPolicyByNameRequest {
	r.name = &name
	return r
}

func (r ApiGetFulfillmentPolicyByNameRequest) Execute() (FulfillmentPolicy, *_nethttp.Response, error) {
	return r.ApiService.GetFulfillmentPolicyByNameExecute(r)
}

/*
GetFulfillmentPolicyByName Method for GetFulfillmentPolicyByName

This method retrieves the complete details for a single fulfillment policy. In the request, supply both the policy <code>name</code> and its associated <code>marketplace_id</code> as query parameters.   <br><br><b>Marketplaces and locales</b>  <br><br>Get the correct policy for a marketplace that supports multiple locales using the <code>Content-Language</code> request header. For example, get a policy for the French locale of the Canadian marketplace by specifying <code>fr-CA</code> for the <code>Content-Language</code> header. Likewise, target the Dutch locale of the Belgium marketplace by setting <code>Content-Language: nl-BE</code>. For details on header values, see <a href="/api-docs/static/rest-request-components.html#HTTP">HTTP request headers</a>.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFulfillmentPolicyByNameRequest
*/
func (a *FulfillmentPolicyApiService) GetFulfillmentPolicyByName(ctx _context.Context) ApiGetFulfillmentPolicyByNameRequest {
	return ApiGetFulfillmentPolicyByNameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FulfillmentPolicy
func (a *FulfillmentPolicyApiService) GetFulfillmentPolicyByNameExecute(r ApiGetFulfillmentPolicyByNameRequest) (FulfillmentPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FulfillmentPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentPolicyApiService.GetFulfillmentPolicyByName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fulfillment_policy/get_by_policy_name"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.marketplaceId == nil {
		return localVarReturnValue, nil, reportError("marketplaceId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("marketplace_id", parameterToString(*r.marketplaceId, ""))
	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFulfillmentPolicyRequest struct {
	ctx _context.Context
	ApiService *FulfillmentPolicyApiService
	fulfillmentPolicyId string
	fulfillmentPolicyRequest *FulfillmentPolicyRequest
}

// Fulfillment policy request
func (r ApiUpdateFulfillmentPolicyRequest) FulfillmentPolicyRequest(fulfillmentPolicyRequest FulfillmentPolicyRequest) ApiUpdateFulfillmentPolicyRequest {
	r.fulfillmentPolicyRequest = &fulfillmentPolicyRequest
	return r
}

func (r ApiUpdateFulfillmentPolicyRequest) Execute() (SetFulfillmentPolicyResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateFulfillmentPolicyExecute(r)
}

/*
UpdateFulfillmentPolicy Method for UpdateFulfillmentPolicy

This method updates an existing fulfillment policy. Specify the policy you want to update using the <b>fulfillment_policy_id</b> path parameter. Supply a complete policy payload with the updates you want to make; this call overwrites the existing policy with the new details specified in the payload.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fulfillmentPolicyId This path parameter specifies the ID of the fulfillment policy you want to update.
 @return ApiUpdateFulfillmentPolicyRequest
*/
func (a *FulfillmentPolicyApiService) UpdateFulfillmentPolicy(ctx _context.Context, fulfillmentPolicyId string) ApiUpdateFulfillmentPolicyRequest {
	return ApiUpdateFulfillmentPolicyRequest{
		ApiService: a,
		ctx: ctx,
		fulfillmentPolicyId: fulfillmentPolicyId,
	}
}

// Execute executes the request
//  @return SetFulfillmentPolicyResponse
func (a *FulfillmentPolicyApiService) UpdateFulfillmentPolicyExecute(r ApiUpdateFulfillmentPolicyRequest) (SetFulfillmentPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SetFulfillmentPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FulfillmentPolicyApiService.UpdateFulfillmentPolicy")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fulfillment_policy/{fulfillmentPolicyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fulfillmentPolicyId"+"}", _neturl.PathEscape(parameterToString(r.fulfillmentPolicyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fulfillmentPolicyRequest == nil {
		return localVarReturnValue, nil, reportError("fulfillmentPolicyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fulfillmentPolicyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
